;; ####
;; Rust
;; ####
;;
;; This file is about finding our way from references to the corresponding
;; definitions.
;;
;; Definitions ("defs") are identifiers in certain specific syntactic
;; positions, where they're naming something.
;;
;; References ("uses") are all other identifiers. Each one refers to some named
;; something.
;;
;; In Rust, if the code compiles, then each reference (apart from a few names
;; like `i32` defined in the language prelude) has a corresponding definition,
;; either in the current crate, a dependency, or the standard library. Finding
;; the definition may involve some poking around.
;;
;; These scoped variables are defined on defs and uses:
;;
;; *   `.def` - On definitions (syntax-nodes for defining identifiers).
;;     A scope-node with the `is_definition` attribute that pops the defined
;;     name.
;;
;; *   `.to_def` - On references (syntax-nodes for non-defining identifiers).
;;     A scope-node with the `is_reference` attribute that leads to the
;;     definition, modulo bugs and unsupported features.
;;
;;
;; # Lexical scoping
;;
;; Not all name lookups work exactly the same way. An identifier that appears
;; after `expr.` or `ty::`, or in a few other syntactic contexts, is qualified.
;; The others, unqualified names, are simply ("simply"!) looked up in the
;; enclosing lexical scope.
;;
;; All syntax-nodes that can contain unqualified uses must have:
;;
;; *   `.scope` - A scope-node that has paths to every definition that's in
;;     scope-- that is, the *enclosing* lexical scope.
;;
;; A node's parent sets its `.scope`, and then the node uses that to resolve
;; unqualified uses (and to set the `.scope` of its own children).
;;
;; ## Inheritance
;;
;; The .scope tree is stitched together with edges that point "up" the tree,
;; toward the root. These trees stop at module nodes, because in Rust, modules
;; do not inherit access to the enclosing block or module's bindings.
;;
;; ## From definitions to uses
;;
;; For types only, we also have a complete separate copy of the scope graph
;; that points in the opposite direction, from definitions to uses. This is
;; necessary to support method lookups, since in Rust methods can be defined
;; anywhere the type name is accessible.
;;
;; *   `.use` - On type references. This is the dual of `.to_def`. It's a
;;     scope-node that pops the name being used.
;;
;; *   `.to_uses` - On type definitions. This is the dual of `.def`. It's a
;;     scope-node that leads to all uses of the type name being defined,
;;     including via type aliases and imports.
;;
;; *   `.scope_uses` - On all syntax-nodes that can contain unqualified uses
;;     of types or modules. The dual of `.scope`. Leads to all uses of type
;;     names in the current scope.
;;
;; The `.scope_uses` tree is stitched together with edges that point "down" the
;; tree, toward the leaves. Like the regular scope trees, the use trees stop at
;; module boundaries.
;;
;; ## Namespaces
;;
;; Rust has separate value and type namespaces. That is, every lexical scope
;; can contain both value bindings and type bindings, and they're distinct, as
;; though the things in the value namespace (functions, local variables,
;; arguments, consts, statics, constructors) and the things in the type
;; namespace (types, modules, crates) always had names that started with
;; distinct invisible sigils. For now we represent these namespaces as two
;; separate nodes. There's an edge from every `.scope` that can contain type
;; bindings to the corresponding type-namespace node, which pops a special
;; symbol `"%types"`; and from every `.scope` that has value bindings to a
;; value-namespace node, which pops `"%values"`.
;;
;; Thus references can't just push the identifier and exit to the scope.
;; References to values must push the identifier, then push `"%values"`, then
;; exit to the scope. References to types must push the type-identifier, then
;; push `"%types"`, then exit to the scope.
;;
;; Lifetimes have their own separate namespace in Rust, but we put them in the
;; type-namespace nodes. Since lifetimes always start with an apostrophe, there
;; can't be any confusion.
;;
;; ## Definitions
;;
;; Syntax-nodes that can contain definitions have:
;;
;; *   `.value_defs`, `.type_defs` - A static-environment rib: has paths to all
;;     values/types defined in this scope, and not inherited from an enclosing
;;     scope.
;;
;; These are sometimes propagated "down" the syntax-tree, toward the leaves,
;; which is necessary (e.g. in pattern syntax and in imports) when we can't
;; match the full path from a scope to a binding with a single tree-sitter
;; query.
;;
;; Nodes that appear in a context where item or import bindings can be
;; introduced--that is, all direct children of `(block)`, `(declaration_list)`,
;; and `(source_file)` nodes, and a few others--have:
;;
;; *   `.item_value_defs`, `.item_type_defs` - The scope-nodes to which this
;;     syntax-node contributes items and imports.
;;
;; Note: Tree-sitter's Rust parser tries to distinguish various uses of
;; identifiers and give them different syntax-node names (like
;; `type_identifier`), but it's imprecise, and there are ambiguous cases built
;; into the Rust language. We therefore often have to make long lists of
;; exactly what nodes or contexts we're talking about.
;;
;; In the scope-uses tree, scope nodes have:
;;
;; *   `.type_uses` - The dual of `.type_defs`. Has paths to all unqualified uses
;;     of types in this scope and not in any enclosing scope.
;;
;; Children of scope nodes have:
;;
;; *   `.item_type_uses` - The dual of `.item_type_defs`. The scope-node to which
;;     this syntax-node contributes uses and imports.
;;
;; # Qualified name lookups
;;
;; We support some name lookups on identifiers qualified by `::`, what the Rust
;; reference calls "paths". These appear in `(scoped_identifier)`,
;; `(scoped_type_identifier)`, and `(scoped_use_list)` nodes.
;;
;; These receive `.scope` from the context, but then it gets complicated,
;; because the unqualified identifier at the start of a path is not resolved
;; using the same rules as other unqualified identifiers; it may refer to a
;; crate from the extern prelude rather than a type, trait, or module in the
;; current lexical scope. Also, paths that start with `crate::`, `self::`,
;; `super::`, or `::` must be treated differently.

global FILE_PATH
global ROOT_NODE

; Magic invocations copied from tree-sitter-typescript.
attribute node_reference = node         => type = "push_symbol", symbol = (source-text node), is_reference, source_node = node
attribute node_symbol = node            => symbol = (source-text node), source_node = node
attribute node_definition = node        => type = "pop_symbol", node_symbol = node, is_definition
attribute push_symbol = symbol          => type = "push_symbol", symbol = symbol
attribute pop_symbol = symbol           => type = "pop_symbol", symbol = symbol

;; # Lexical scopes
;;
;; In which we attach `.scope` nodes to every syntax node that needs them, and
;; connect these nodes in a scope tree.
;;
;; Most nodes simply inherit these scopes from their parent. The last rule of
;; this section is a massive query listing every one of these trivial cases.
;; The rest of the section covers the special cases.

;; ## Root scopes
[
  (source_file) @root
  (mod_item body: (declaration_list) @root)
] {
  ;; Modules, including nested modules, have fresh scopes. No inheritance.
  ;; (Ideally, these should inherit from the standard prelude and the extern
  ;; prelude, but we currently have no information about what to put in those
  ;; namespaces.)
  node @root.scope
  node @root.scope_uses
}

;; ## Expression scopes

;; Expressions that introduce local bindings, either with patterns or loop
;; labels.
;;
;; *   `.inner_scope` - On expression nodes that introduce a nested scope and
;;     have a "body". The nested body scope. (For generics, see
;;     `.generic_scope`. For function and closure body scopes, see "Function
;;     and closure parameters".)
;;
;; *   `.inner_scope_uses` - On the same nodes as `.inner_scope`. The dual of
;;     `.inner_scope`. Has in-edges from definitions in the inner scope. Leads
;;     leafward to all uses.
[
  (for_expression (loop_label)? @label pattern: (_) @pat)
  (if_let_expression pattern: (_) @pat)
  (loop_expression (loop_label)? @label)
  (match_arm pattern: (_) @pat)
  (while_expression (loop_label)? @label)
  (while_let_expression (loop_label)? @label pattern: (_) @pat)
] @parent {
  if some @label {
    node @parent.inner_scope
    edge @parent.inner_scope -> @parent.scope

    node @parent.inner_scope_uses
    edge @parent.scope_uses -> @parent.inner_scope_uses

    if some @pat {
      ;; Create the "definitions" node to which the pattern contributes bindings.
      ;;
      ;; A similar node is created everywhere patterns are used (let-declarations
      ;; and parameters).
      ;;
      ;; Here and throughout, an edge from a scope node to definition nodes has
      ;; precedence 1, higher than scope-inheritance edges (precedence 0), so that
      ;; inner bindings are preferred over (i.e. they shadow) outer bindings.
      node @pat.value_defs
      attr (@pat.value_defs) pop_symbol = "%values"
      edge @parent.inner_scope -> @pat.value_defs
      attr (@parent.inner_scope -> @pat.value_defs) precedence = 1
    }

    node def_loops
    attr (def_loops) pop_symbol = "%loop"
    edge @parent.inner_scope -> def_loops
    attr (@parent.inner_scope -> def_loops) precedence = 1

    ; Bind the label in the loop namespace
    node @label.def
    attr (@label.def) node_definition = @label
    edge def_loops -> @label.def
  } else {
    if some @pat {
      node @parent.inner_scope
      edge @parent.inner_scope -> @parent.scope

      node @pat.value_defs
      attr (@pat.value_defs) pop_symbol = "%values"
      edge @parent.inner_scope -> @pat.value_defs
      attr (@parent.inner_scope -> @pat.value_defs) precedence = 1

      node @parent.inner_scope_uses
      edge @parent.scope_uses -> @parent.inner_scope_uses
    } else {
      let @parent.inner_scope = @parent.scope
      let @parent.inner_scope_uses = @parent.scope_uses
    }
  }
}

;; Subpatterns inherit the parent's defs node.
[
  (captured_pattern (identifier) "@" (_) @pat) @parent
  (captured_pattern (identifier) @pat "@" (_)) @parent
  (field_pattern name: (shorthand_field_identifier) @pat) @parent
  (field_pattern pattern: (_) @pat) @parent
  (match_pattern . (_) @pat) @parent
  (mut_pattern (mutable_specifier) (_) @pat) @parent
  (or_pattern (_) @pat) @parent
  (ref_pattern (_) @pat) @parent
  (reference_pattern "&" (mutable_specifier)? (_) @pat) @parent
  (slice_pattern (_) @pat) @parent
  (struct_pattern (field_pattern) @pat) @parent
  (tuple_pattern (_) @pat) @parent
  (tuple_struct_pattern type: (_) (_) @pat) @parent
] {
  let @pat.value_defs = @parent.value_defs
}

;; Assign the children of these expressions the inner_scope of their parents.
[
  (for_expression body: (_) @child) @parent
  (if_let_expression alternative: (_) @child) @parent
  (loop_expression body: (_) @child) @parent
  (match_arm pattern: (match_pattern condition: (_) @child)) @parent
  (match_arm value: (_) @child) @parent
  (while_expression body: (_) @child) @parent
  (while_let_expression body: (_) @child) @parent
] {
  let @child.scope = @parent.inner_scope
  let @child.scope_uses = @parent.inner_scope_uses
}

;; Identifier-patterns are definitions.
;;
;; (This isn't entirely true. In Rust, if the identifier resolves to a constant
;; or enum variant, it's not a shadowing definition; instead it's a pattern
;; that matches that exact value. But it's not clear how such a rule can be
;; implemented.)
[
  (for_expression pattern: (identifier) @ident)
  (if_let_expression pattern: (identifier) @ident)
  (while_let_expression pattern: (identifier) @ident)
  (let_declaration pattern: (identifier) @ident)
  (parameter pattern: (identifier) @ident)
  (closure_parameters (identifier) @ident)
  (match_pattern . (identifier) @ident)
  (tuple_pattern (identifier) @ident)
  (tuple_struct_pattern type: (_) (identifier) @ident)
  (slice_pattern (identifier) @ident)
  (field_pattern name: (shorthand_field_identifier) @ident)
  (field_pattern pattern: (identifier) @ident)
  (mut_pattern (mutable_specifier) (identifier) @ident)
  (ref_pattern (identifier) @ident)
  (captured_pattern (identifier) @ident "@" (_))
  (captured_pattern (identifier) "@" (identifier) @ident)
  (reference_pattern "&" (mutable_specifier)? (identifier) @ident)
  (or_pattern (identifier) @ident)
] {
  node @ident.def
  attr (@ident.def) node_definition = @ident
  edge @ident.value_defs -> @ident.def

  node @ident.type
  node t
  attr (t) pop_symbol = "%type"
  edge @ident.def -> t
  edge t -> @ident.expected_type
}

;; ## Generic parameters
;;
;; *   `.generic_scope` - On items that can have generics. The scope that
;;     contains generic parameters. (As an implementation detail, this
;;     exists on closures, too.)
;;
;; *   `.generic_scope_uses` - On the same items as `.generic_scope`. The
;;     dual of `.generic_scope`. Contains in-edges from the `.to_uses` of each
;;     generic parameter definition. Leads leafward to all their uses.
;;
;; *   `.const_param_defs` - On items with type parameters. Node that pops
;;     %values and has edges to each const parameter definition.
;;
;; *   `.type_param_defs` - On items with type parameters. Node that pops
;;     %types and has edges to each type parameter and lifetime parameter
;;     definition.
;;
;; *   `.type_param_uses` - On items that have `.type_param_defs`. The dual
;;     of `.type_param_defs`. Node that pushes "%types" and leads to
;;     all uses of type names defined in the current scope.
[
  (associated_type type_parameters: (type_parameters)? @params)
  (enum_item type_parameters: (type_parameters)? @params)
  (function_item type_parameters: (type_parameters)? @params)
  (function_signature_item type_parameters: (type_parameters)? @params)
  (impl_item type_parameters: (type_parameters)? @params)
  (struct_item type_parameters: (type_parameters)? @params)
  (trait_item type_parameters: (type_parameters)? @params)
  (type_item type_parameters: (type_parameters)? @params)
  (union_item type_parameters: (type_parameters)? @params)
  (function_type (for_lifetimes)? @params)
] @parent {
  if some @params {
    node @parent.generic_scope
    edge @parent.generic_scope -> @parent.scope

    node @params.const_param_defs
    attr (@params.const_param_defs) pop_symbol = "%values"
    edge @parent.generic_scope -> @params.const_param_defs
    attr (@parent.generic_scope -> @params.const_param_defs) precedence = 1

    node @params.type_param_defs
    attr (@params.type_param_defs) pop_symbol = "%types"
    edge @parent.generic_scope -> @params.type_param_defs
    attr (@parent.generic_scope -> @params.type_param_defs) precedence = 1

    ;; Duals.
    node @parent.generic_scope_uses
    edge @parent.scope_uses -> @parent.generic_scope_uses

    node @params.type_param_uses
    attr (@params.type_param_uses) push_symbol = "%type_uses"
    edge @params.type_param_uses -> @parent.generic_scope_uses
    ;; XXX TODO - explain why no precedence here
  } else {
    ;; An item that could have type parameters, but in fact doesn't, also needs
    ;; a `.generic_scope`, but it's just the same node as the enclosing scope.
    let @parent.generic_scope = @parent.scope
    let @parent.generic_scope_uses = @parent.scope_uses
  }
}

; Generic parameters are definitions.
[
  (type_parameters (lifetime) @lifetime)
  (type_parameters (constrained_type_parameter left: (lifetime) @lifetime))
  (for_lifetimes (lifetime) @lifetime)
] @params {
  node @lifetime.def
  attr (@lifetime.def) node_definition = @lifetime
  edge @params.type_param_defs -> @lifetime.def
}

[
  (type_parameters (type_identifier) @ident)
  (type_parameters (constrained_type_parameter left: (type_identifier) @ident))
] @params {
  node @ident.def
  attr (@ident.def) node_definition = @ident
  edge @params.type_param_defs -> @ident.def

  ;; Dual
  node @ident.to_uses
  attr (@ident.to_uses) push_symbol = (source-text @ident)
  edge @ident.to_uses -> @params.type_param_uses

  ;; Bridge from def to uses
  node u
  attr (u) pop_symbol = "%uses"
  edge @ident.def -> u
  edge u -> @ident.to_uses
}

(type_parameters (const_parameter name: (_) @ident)) @params {
  node @ident.def
  attr (@ident.def) node_definition = @ident
  edge @params.const_param_defs -> @ident.def
}

(const_parameter
  name: (_) @ident
  type: (_) @type
) {
  node t
  attr (t) pop_symbol = "%type"
  edge @ident.def -> t
  edge t -> @type.to_def
}

;; Direct children of generics get the scope that contains generic parameter
;; bindings.
;;
;; This lists all contexts in most items, except the name,
;; and all contexts within a function except the name and the body;
;; the body is special because it also sees the function parameter bindings.
[
  (associated_type type_parameters: (_) @child) @parent
  (associated_type bounds: (_) @child) @parent
  (enum_item type_parameters: (_) @child) @parent
  (enum_item (where_clause) @child) @parent
  (enum_item body: (_) @child) @parent
  (function_item type_parameters: (_) @child) @parent
  (function_item parameters: (_) @child) @parent
  (function_item return_type: (_) @child) @parent
  (function_item (where_clause) @child) @parent
  (function_signature_item (_) @child) @parent
  (impl_item type_parameters: (_) @child) @parent
  (impl_item trait: (_) @child) @parent
  (impl_item type: (_) @child) @parent
  (impl_item (where_clause) @child) @parent
  (impl_item body: (_) @child) @parent
  (struct_item type_parameters: (_) @child) @parent
  (struct_item (where_clause) @child) @parent
  (struct_item body: (_) @child) @parent
  (trait_item type_parameters: (_) @child) @parent
  (trait_item bounds: (_) @child) @parent
  (trait_item (where_clause) @child) @parent
  (trait_item body: (_) @child) @parent
  (type_item type_parameters: (_) @child) @parent
  (type_item type: (_) @child) @parent
  (union_item type_parameters: (_) @child) @parent
  (union_item body: (_) @child) @parent

  (function_type trait: (_) @child) @parent  ;; only for Fn, FnMut, FnOnce
  (function_type parameters: (_) @child) @parent
  (function_type return_type: (_) @child) @parent
] {
  let @child.scope = @parent.generic_scope
  let @child.scope_uses = @parent.generic_scope_uses
}

;; ## Block scopes
;;
;; Items in a block are visible throughout the block. Let-declaration bindings
;; in a block are visible starting with the next statement or expression.
;;
;; *   `.block_item_scope` - On block nodes. Scope in which block-scoped items
;;     are defined. Has edges to the "%types" and "%values" namespaces.
;;
;; *   `.block_item_value_defs`, `.block_item_type_defs` - On block nodes.
;;     Namespace nodes. These have edges to the types and values defined in the
;;     scope. These are the nodes that serve as `@child.item_value_defs` and
;;     `@child.item_type_defs` for each child. `.block_item_value_defs` does
;;     not contain any `let`-bindings, only const, static, and tuple-struct
;;     bindings.
;;
;; *   `.block_item_scope_uses` - On block nodes. Dual of `.block_item_scope`.
;;     Has inbound edges from type definitions in the block; leads to all uses
;;     of those type names.
;;
;; *   `.block_item_type_uses` - On block nodes. Dual of
;;     `.block_item_type_defs`. Leads to type uses in items in the block. Used
;;     as `@child.item_type_uses` for each child.
;;
;; *   `.block_scope_after` - Defined on every child of a block. Determined by
;;     that child. The scope for the next child.

;; Create the item scope.
(block) @block {
  node @block.block_item_scope
  edge @block.block_item_scope -> @block.scope

  node @block.block_item_value_defs
  attr (@block.block_item_value_defs) pop_symbol = "%values"
  edge @block.block_item_scope -> @block.block_item_value_defs
  attr (@block.block_item_scope -> @block.block_item_value_defs) precedence = 1

  node @block.block_item_type_defs
  attr (@block.block_item_type_defs) pop_symbol = "%types"
  edge @block.block_item_scope -> @block.block_item_type_defs
  attr (@block.block_item_scope -> @block.block_item_type_defs) precedence = 1

  ;; Duals
  node @block.block_item_scope_uses
  edge @block.scope_uses -> @block.block_item_scope_uses

  node @block.block_item_type_uses
  attr (@block.block_item_type_uses) push_symbol = "%type_uses"
  edge @block.block_item_type_uses -> @block.block_item_scope_uses
}

;; Tell block-scoped items where to add definitions.
;;
;; (The two scoped variables `.item_value_defs` and `item_values` look like
;; they ought to have the same name, but that wouldn't work. The selector here
;; does not select only item children but all children; one of those children
;; might be another block, and then there'd be a conflict.)
(block (_) @child) @parent {
  let @child.item_value_defs = @parent.block_item_value_defs
  let @child.item_type_defs = @parent.block_item_type_defs
  let @child.item_type_uses = @parent.block_item_type_uses
}

;; The next two rules define each child's `.scope`.
(block . (_) @first_child) @block {
  let @first_child.scope = @block.block_item_scope
}

(block (_) @prev . (_) @next) @block {
  let @next.scope = @prev.block_scope_after
}

;; Dual to the above two rules. Asymmetric because let-bindings aren't in the
;; scope_uses tree.
(block (_) @child) @block {
  let @child.scope_uses = @block.block_item_scope_uses
}

;; The next two rules define `.block_scope_after` for each statement child.
(let_declaration pattern: (_)? @pat) @stmt {
  if some @pat {
    ;; Create the "definitions" node for let-bindings.
    node @pat.value_defs
    attr (@pat.value_defs) pop_symbol = "%values"
    node @stmt.block_scope_after
    edge @stmt.block_scope_after -> @pat.value_defs
    attr (@stmt.block_scope_after -> @pat.value_defs) precedence = 1
    edge @stmt.block_scope_after -> @stmt.scope
  } else {
    let @stmt.block_scope_after = @stmt.scope
  }
}

(block [
  ;; This is every node type that can appear in a block as a statement, except
  ;; `let_declaration`. Awkward but I don't know how else to write this.
  (empty_statement)
  (expression_statement)
  (line_comment)
  (macro_definition)
  (attribute_item)
  (inner_attribute_item)

  (associated_type)
  (enum_item)
  (extern_crate_declaration)
  (foreign_mod_item)
  (function_item)
  (function_signature_item)
  (impl_item)
  (mod_item)
  (static_item)
  (struct_item)
  (trait_item)
  (type_item)
  (union_item)
  (use_declaration)
  (const_item)
] @stmt) {
  let @stmt.block_scope_after = @stmt.scope
}



;; ## Default scope propagation
;;
;; Propagate scope for all syntax that does not introduce bindings.
[
  ;; Items in the file-level module scope
  (source_file (_) @child) @parent

  ;; ### Types
  ;; function_type is not listed because it can have `for_lifetimes`,
  ;; which affect the scope of its children.
  (abstract_type trait: (_) @child) @parent
  (array_type element: (_) @child) @parent
  (array_type length: (_) @child) @parent
  (bounded_type (_) @child) @parent
  (bracketed_type (_) @child) @parent
  (dynamic_type trait: (_) @child) @parent
  (generic_type type: (_) @child) @parent
  (generic_type type_arguments: (_) @child) @parent
  (pointer_type type: (_) @child) @parent
  (qualified_type type: (_) @child) @parent
  (qualified_type alias: (_) @child) @parent
  (reference_type (lifetime) @child) @parent
  (reference_type type: (_) @child) @parent
  (tuple_type (_) @child) @parent
  (type_arguments (_) @child) @parent
  ;;(type_binding type_arguments: (_) @child) @parent  ;; bogus grammar
  (type_binding type: (_) @child) @parent

  ;; ### Expressions
  (arguments (_) @child) @parent
  (array_expression (_) @child) @parent
  (array_expression length: (_) @child) @parent
  (assignment_expression left: (_) @child) @parent
  (assignment_expression right: (_) @child) @parent
  (async_block (_) @child) @parent
  (await_expression (_) @child) @parent
  (base_field_initializer (_) @child) @parent
  (binary_expression left: (_) @child) @parent
  (binary_expression right: (_) @child) @parent
  (break_expression (_) @child) @parent
  (call_expression function: (_) @child) @parent
  (call_expression arguments: (_) @child) @parent
  (closure_expression parameters: (_) @child) @parent
  (closure_expression return_type: (_) @child) @parent
  (compound_assignment_expr left: (_) @child) @parent
  (compound_assignment_expr right: (_) @child) @parent
  (const_block body: (_) @child) @parent
  (continue_expression (_) @child) @parent
  (else_clause (_) @child) @parent
  (field_expression value: (_) @child) @parent
  (field_initializer_list (_) @child) @parent
  (field_initializer value: (_) @child) @parent
  (for_expression pattern: (_) @child) @parent
  (for_expression value: (_) @child) @parent
  (generic_function function: (_) @child) @parent
  (generic_function type_arguments: (_) @child) @parent
  (if_expression condition: (_) @child) @parent
  (if_expression alternative: (_) @child) @parent
  (if_expression consequence: (_) @child) @parent
  (if_let_expression pattern: (_) @child) @parent
  (if_let_expression value: (_) @child) @parent
  (if_let_expression alternative: (_) @child) @parent
  (index_expression (_) @child) @parent
  (macro_invocation macro: (_) @child) @parent
  (match_arm pattern: (_) @child) @parent
  (match_block (_) @child) @parent
  (match_expression value: (_) @child) @parent
  (match_expression body: (_) @child) @parent
  (match_pattern . (_) @child) @parent
  (parenthesized_expression (_) @child) @parent
  (range_expression (_) @child) @parent
  (reference_expression value: (_) @child) @parent
  (return_expression (_) @child) @parent
  (shorthand_field_initializer (_) @child) @parent
  (struct_expression name: (_) @child) @parent
  (struct_expression body: (_) @child) @parent
  (try_expression (_) @child) @parent
  (tuple_expression (_) @child) @parent
  (type_cast_expression value: (_) @child) @parent
  (type_cast_expression type: (_) @child) @parent
  (unary_expression (_) @child) @parent
  (unsafe_block (_) @child) @parent
  (while_expression condition: (_) @child) @parent
  (while_let_expression pattern: (_) @child) @parent
  (while_let_expression value: (_) @child) @parent
  (yield_expression (_) @child) @parent

  ;; ### Statements
  (let_declaration pattern: (_) @child) @parent
  (let_declaration type: (_) @child) @parent
  (let_declaration value: (_) @child) @parent
  (expression_statement (_) @child) @parent

  ;; ### Patterns
  (captured_pattern (identifier) "@" (_) @child) @parent
  (captured_pattern (identifier) @child "@" (_)) @parent
  (field_pattern (_) @child) @parent
  (mut_pattern (mutable_specifier) (_) @child) @parent
  (or_pattern (_) @child) @parent
  (range_pattern (_) @child) @parent
  (ref_pattern (_) @child) @parent
  (reference_pattern (_) @child) @parent
  (slice_pattern (_) @child) @parent
  (struct_pattern (_) @child) @parent
  (tuple_pattern (_) @child) @parent
  (tuple_struct_pattern (_) @child) @parent

  ;; ### Items
  ;; Of course all items are declarations and introduce bindings into the
  ;; enclosing scope. But the real reason fn/impl/struct/enum/union/type/trait
  ;; are not here is that they can have type parameters, which affect the scope
  ;; of everything in them. (Functions, of course, can even have regular old
  ;; function parameters. Worse and worse!)
  ;;
  ;; The names of all these items, though, are in the enclosing scope (so that
  ;; you can look them up and they'll find themselves).
  ;;
  ;; Modules are not present because they reset the scope. `foreign_mod_item`
  ;; is what the Rust reference calls an `ExternBlock` or "external block".
  ;; It's not a module and it does propagate scope.
  (const_item type: (_) @child) @parent
  (const_item value: (_) @child) @parent
  (declaration_list (_) @child) @parent
  (enum_variant_list (_) @child) @parent
  (enum_variant body: (_) @child) @parent
  (enum_variant value: (_) @child) @parent
  (field_declaration type: (_) @child) @parent
  (field_declaration_list (_) @child) @parent
  (ordered_field_declaration_list (_) @child) @parent
  (foreign_mod_item body: (_) @child) @parent
  (parameter pattern: (_) @child) @parent
  (parameter type: (_) @child) @parent
  (self_parameter (lifetime) @child) @parent
  (parameters (_) @child) @parent
  (static_item type: (_) @child) @parent
  (static_item value: (_) @child) @parent
  (where_clause (where_predicate) @child) @parent
  (where_predicate left: (_) @child) @parent
  (where_predicate bounds: (_) @child) @parent
  (trait_bounds (_) @child) @parent
  (type_parameters (constrained_type_parameter bounds: (_) @child)) @parent
  (removed_trait_bound (_) @child) @parent

  ;; For import syntax, see the "Imports" section below.
] {
  let @child.scope = @parent.scope
  let @child.scope_uses = @parent.scope_uses
}



;; # Unqualified identifiers

;; ## Identifiers in expression context
;;
;; List all contexts where an identifier is a reference to a binding in the
;; "values" namespace.
;;
;; In many contexts, it is not:
;; -   after `let x:`, or before `::`, or inside `<...>`, or after `as`,
;;     it refers to something in the type namespace
;; -   in `#[...]` it refers to an attribute, or something
;; -   before `!` it refers to a macro
;; -   between `.` and `(` it refers to a method
;; -   otherwise after `.` it refers to a field
;; -   and of course, if it's the name of an item or binding,
;;     it isn't a reference at all.
;;
;; The grammar parses many of these as `identifier` syntax nodes, so it's
;; necessary to use a giant pattern to get only expression contexts.
[
  ;; ### Expressions
  (arguments [(identifier) (self)] @ident)
  (array_expression [(identifier) (self)] @ident)
  (assignment_expression left: [(identifier) (self)] @ident)
  (assignment_expression right: [(identifier) (self)] @ident)
  (await_expression [(identifier) (self)] @ident)
  (base_field_initializer [(identifier) (self)] @ident)
  (binary_expression left: [(identifier) (self)] @ident)
  (binary_expression right: [(identifier) (self)] @ident)
  (break_expression [(identifier) (self)] @ident)
  (call_expression function: [(identifier) (self)] @ident)
  (compound_assignment_expr left: [(identifier) (self)] @ident)
  (compound_assignment_expr right: [(identifier) (self)] @ident)
  (field_expression value: [(identifier) (self)] @ident)
  (field_initializer value: [(identifier) (self)] @ident)
  (for_expression value: [(identifier) (self)] @ident)
  (generic_function function: [(identifier) (self)] @ident)
  (if_expression condition: [(identifier) (self)] @ident)
  (if_let_expression value: [(identifier) (self)] @ident)
  (index_expression [(identifier) (self)] @ident)
  (match_expression value: [(identifier) (self)] @ident)
  (match_pattern condition: [(identifier) (self)] @ident)
  (parenthesized_expression [(identifier) (self)] @ident)
  (range_expression [(identifier) (self)] @ident)
  (reference_expression value: [(identifier) (self)] @ident)
  (return_expression [(identifier) (self)] @ident)
  (shorthand_field_initializer [(identifier) (self)] @ident)
  (try_expression [(identifier) (self)] @ident)
  (tuple_expression [(identifier) (self)] @ident)
  (type_cast_expression value: [(identifier) (self)] @ident)
  (unary_expression [(identifier) (self)] @ident)
  (while_expression condition: [(identifier) (self)] @ident)
  (while_let_expression value: [(identifier) (self)] @ident)
  (yield_expression [(identifier) (self)] @ident)

  ;; ### Patterns
  (tuple_struct_pattern type: [(identifier) (self)] @ident)

  ;; ### Types
  (array_type length: [(identifier) (self)] @ident)

  ;; ### Statements
  (block (_)* [(identifier) (self)] @ident)
  (expression_statement [(identifier) (self)] @ident)
  (let_declaration value: [(identifier) (self)] @ident)

  ;; ### Items
  (const_item value: [(identifier) (self)] @ident)
  (static_item value: [(identifier) (self)] @ident)
] {
  node @ident.to_def
  attr (@ident.to_def) node_reference = @ident
  node v
  attr (v) push_symbol = "%values"
  edge @ident.to_def -> v
  edge v -> @ident.scope

  node @ident.use

  node @ident.type
  attr (@ident.type) push_symbol = "%type"
  edge @ident.type -> @ident.to_def
}

;; ## Identifiers in type context
;;
;; List all contexts where an identifier is a reference to a binding in the
;; "types" namespace of the current scope.
;;
;; The grammar also parses the following as `type_identifier`:
;; - names of many items, like the `X` in `struct X {}`
;; - type parameters, like the `T` in `fn f<T>() {}`
;; - the `Item` in `Iterator<Item=T>`
;; - identifiers after `::` when they refer to types
;; None of these should match here, so it's necessary to use a huge pattern to
;; get only type-expression contexts.
;;
;; Identifiers immediately before `::` in a `scoped_identifier` can sometimes
;; be the name of a type, but not always, so that too is handled elsewhere for
;; now.
[
  ;; ### Types
  (abstract_type trait: (type_identifier) @ident)
  (array_type element: (type_identifier) @ident)
  (bounded_type (type_identifier) @ident)
  (dynamic_type trait: (type_identifier) @ident)
  (function_type trait: (type_identifier) @ident)  ;; only for Fn, FnMut, FnOnce
  (function_type return_type: (type_identifier) @ident)
  (generic_type type: (type_identifier) @ident)
  (generic_type_with_turbofish type: (type_identifier) @ident)
  (pointer_type type: (type_identifier) @ident)
  (qualified_type type: (type_identifier) @ident)
  (qualified_type alias: (type_identifier) @ident)
  (reference_type type: (type_identifier) @ident)
  (tuple_type (type_identifier) @ident)
  (type_arguments (type_identifier) @ident) ;; ambiguous, but treat as a type for now
  (type_binding type: (type_identifier) @ident)

  ;; ### Expressions
  (type_cast_expression type: (type_identifier) @ident)
  (bracketed_type (type_identifier) @ident)
  (struct_expression name: (type_identifier) @ident)

  ;; ### Patterns
  (struct_pattern type: (type_identifier) @ident)

  ;; ### Items
  (const_item type: (type_identifier) @ident)
  (field_declaration type: (type_identifier) @ident)
  (function_item return_type: (type_identifier) @ident)
  (impl_item trait: (type_identifier) @ident)
  (impl_item type: (type_identifier) @ident)
  (ordered_field_declaration_list type: (type_identifier) @ident)
  (parameter type: (type_identifier) @ident)
  (static_item type: (type_identifier) @ident)
  (type_item type: (type_identifier) @ident)
  (trait_bounds (type_identifier) @ident)
  (where_predicate left: (type_identifier) @ident)

  ;; ### Statements
  (let_declaration type: (type_identifier) @ident)
] {
  node @ident.to_def
  attr (@ident.to_def) node_reference = @ident

  let t = (node)
  attr (t) push_symbol = "%types"
  edge @ident.to_def -> t
  edge t -> @ident.scope

  ;; Duals.
  node @ident.use
  attr (@ident.use) pop_symbol = (source-text @ident)

  let u = (node)
  attr (u) pop_symbol = "%type_uses"
  edge u -> @ident.use
  edge @ident.scope_uses -> u
}



;; # Item definitions
;;
;; *   `.def_any` - On `(mod_item)` nodes. The node that pops `"%any"` and
;;     leads to both type and value bindings. Used by imports.

[
  (source_file) @body
  (mod_item body: (declaration_list) @body)
  (foreign_mod_item body: (declaration_list) @body)
  (impl_item body: (declaration_list) @body) @impl_or_trait
  (trait_item body: (declaration_list) @body) @impl_or_trait
] {
  ;; `impl` and `trait` items contain definitions, but the defined items are
  ;; not bound in the lexical scope. However, they also should have a lexical
  ;; scope that binds `Self` (TODO).
  var defs = #null
  if some @impl_or_trait {
    set defs = @impl_or_trait.impl_or_trait_defs
  } else {
    set defs = @body.scope
  }

  node @body.type_defs
  attr (@body.type_defs) pop_symbol = "%types"
  edge defs -> @body.type_defs
  attr (defs -> @body.type_defs) precedence = 1

  node @body.value_defs
  attr (@body.value_defs) pop_symbol = "%values"
  edge defs -> @body.value_defs
  attr (defs -> @body.value_defs) precedence = 1

  if none @impl_or_trait {
    ;; This `%any` namespace is the union of `%types` and `%values`. The .scope
    ;; does not have an edge to this, because all ordinary lexical-scope lookups
    ;; are for either a type or a value. Imports use it, because the `use` syntax
    ;; is the same whether importing types or values.
    node @body.def_any
    attr (@body.def_any) pop_symbol = "%any"
    node to_types
    attr (to_types) push_symbol = "%types"
    node to_values
    attr (to_values) push_symbol = "%values"
    edge @body.def_any -> to_types
    edge to_types -> @body.type_defs
    edge @body.def_any -> to_values
    edge to_values -> @body.value_defs

    ;; Dual of "%types" for lexical scopes. XXX ??? Not sure what if anything
    ;; to do for uses of items defined in `impl` and `trait` bodies.
    node @body.type_uses
    attr (@body.type_uses) push_symbol = "%type_uses"
    edge @body.type_uses -> @body.scope_uses
  }
}

[
  (source_file (_) @child) @parent
  (declaration_list (_) @child) @parent
] {
  let @child.item_value_defs = @parent.value_defs
  let @child.item_type_defs = @parent.type_defs
  let @child.item_type_uses = @parent.type_uses
}

[
  (const_item name: (_) @name)
  (enum_item name: (_) @name)
  (function_item name: (_) @name)
  (static_item name: (_) @name)
  (struct_item name: (_) @name)
  (trait_item name: (_) @name)
  (type_item name: (_) @name)
  (union_item name: (_) @name)
] @item {
  node @item.def
  attr (@item.def) node_definition = @name

  ;; Dual
  node @item.to_uses
  attr (@item.to_uses) push_symbol = (source-text @name)

  ;; Bridge from def to uses
  node u
  attr (u) pop_symbol = "%uses"
  edge @item.def -> u
  edge u -> @item.to_uses
}

[
  (enum_item name: (_) @name)
  (struct_item name: (_) @name)
  (trait_item name: (_) @name)
  (union_item name: (_) @name)
] @item {
  node m1
  attr (m1) pop_symbol = "%methods"
  node m2
  attr (m2) push_symbol = "%values"
  node m3
  attr (m3) push_symbol = "%impls"
  edge @item.def -> m1
  edge m1 -> m2
  edge m2 -> m3
  edge m3 -> @item.to_uses
}

(mod_item name: (_) @name body: (_)? @body) @item {
  if some @body {
    node @item.def
    attr (@item.def) node_definition = @name

    ;; Dual
    node @item.to_uses
    attr (@item.to_uses) push_symbol = (source-text @name)

    ;; Bridge from def to uses
    node u
    attr (u) pop_symbol = "%uses"
    edge @item.def -> u
    edge u -> @item.to_uses
  } else {
    ;; The difficult case: find the node for this module in another file.
    node @item.def
    attr (@item.def) pop_symbol = (source-text @name)
    ;; We're looking for this module item's name...
    node relay1
    attr (relay1) push_symbol = (source-text @name)
    ;; in the type namespace...
    node relay2
    attr (relay2) push_symbol = "%types"
    ;; of the node in another file...
    node relay3
    attr (relay3) push_symbol = "%anyfile"
    ;; that represents the current enclosing module (`self`).
    node relay4
    attr (relay4) push_symbol = "self"
    node relay5
    attr (relay5) push_symbol = "%types"

    edge @item.def -> relay1
    edge relay1 -> relay2
    edge relay2 -> relay3
    edge relay3 -> relay4
    edge relay4 -> relay5
    edge relay5 -> @item.scope

    ;; XXX TODO - Duals.
  }
}

;; Bind items in the type namespace.
[
  (enum_item)
  (mod_item)
  (struct_item)
  (trait_item)
  (type_item)
  (union_item)
] @item {
  edge @item.item_type_defs -> @item.def
  edge @item.to_uses -> @item.item_type_uses
}

;; # Bindings for items in the value namespace

;; Bind fn items in the value namespace.
(function_item) @item {
  edge @item.item_value_defs -> @item.def
}

;; Attach the declared return type of fn items that have a simple return type.
;; (If the function returns a type we can't resolve, or the return type is
;; implicitly unit, we don't bother.)
(function_item
  return_type: [
    ;; List of nodes matching `$._type` that have `.to_def`
    (type_identifier)
    (scoped_type_identifier)
  ] @rtype
) @item {
  node t1
  attr (t1) pop_symbol = "%type"
  node t2
  attr (t2) pop_symbol = "%rtype"
  edge @item.def -> t1
  edge t1 -> t2
  edge t2 -> @rtype.to_def
}

;; Bind const and static items in the value namespace and attach their declared
;; type.
[
  (const_item type: (_) @type)
  (static_item type: (_) @type)
] @item {
  edge @item.item_value_defs -> @item.def

  node t
  attr (t) pop_symbol = "%type"
  edge @item.def -> t
  edge t -> @type.to_def
}

;; Bind tuple-like structs in the value namespace. We use the same node for the
;; struct type and its constructor. The type of the constructor is a function
;; type whose return type is the struct itself.
(struct_item body: (ordered_field_declaration_list)) @item {
  edge @item.item_value_defs -> @item.def

  node t1
  attr (t1) pop_symbol = "%type"
  node t2
  attr (t2) pop_symbol = "%rtype"
  edge @item.def -> t1
  edge t1 -> t2
  edge t2 -> @item.def
}

;; Bind unit-like structs in the value namespace. We use the same node for the
;; struct type and its constructor.
(struct_item body: (_)? @body) @item {
  if none @body {
    edge @item.item_value_defs -> @item.def

    node t
    attr (t) pop_symbol = "%type"
    edge @item.def -> t
    edge t -> @item.def
  }
}

;; *   `.impl_or_trait_defs` - On `(impl_item)` and `(trait_item)` nodes.
;;     The node that has `%values` and `%types` edges leading to the defined
;;     methods and/or other items.
[
  (impl_item)
  (trait_item)
] @item {
  node @item.impl_or_trait_defs
}

;; Support looking up all impls of a type from its definition via `"%uses"`.
(impl_item type: (_) @type) @item {
  node impls
  attr (impls) pop_symbol = "%impls"
  edge @type.use -> impls
  edge impls -> @item.impl_or_trait_defs
}



;; # Function and closure parameters

;; This is awkward because `closure_parameters` have two different structures
;; only one of which (`parameter`) can be easily distinguished with a query.
;;
;; TODO - See if this can be made any tidier.

[(parameters) (closure_parameters)] @parameters {
  node @parameters.value_defs
  attr (@parameters.value_defs) pop_symbol = "%values"
}

[
  (parameters (parameter) @child)
  (parameters (self_parameter) @child)
  (closure_parameters (_) @child)
] @parameters {
  let @child.value_defs = @parameters.value_defs
}

(parameter pattern: (_) @pat) @param {
  let @pat.value_defs = @param.value_defs
}

(self_parameter (self) @self) @param {
  node @self.def
  attr (@self.def) node_definition = @self
  edge @param.value_defs -> @self.def
}

(closure_expression) @closure {
  ;; Used below. Just an alias, because closures don't have type parameters.
  let @closure.generic_scope = @closure.scope
  let @closure.generic_scope_uses = @closure.scope_uses
}

[
  (closure_expression parameters: (_) @parameters body: (_) @body)
  (function_item parameters: (_) @parameters body: (_) @body)
] @parent {
  node @body.scope
  edge @body.scope -> @parameters.value_defs
  attr (@body.scope -> @parameters.value_defs) precedence = 1
  edge @body.scope -> @parent.generic_scope

  ;; Dual. This new scope isn't really necessary, as it never has any type
  ;; bindings in it, but we keep it for symmetry.
  node @body.scope_uses
  edge @parent.generic_scope_uses -> @body.scope_uses
}


;; # Binding the file module
;;
;; In which we help folks coming in from the root node to tell if the path
;; they're looking for is really located in this file.
(source_file) @root {
  ;; Every file in the crate contributes to the same tree of modules, but they
  ;; can't share scope-nodes (except ROOT_NODE). So for each source file, this
  ;; code builds a separate copy of the path from the root of that tree to one
  ;; leaf module.

  ;; Thus every file in the crate has its own `crate_defs` node.
  node crate_defs
  attr (crate_defs) source_node = @root, pop_symbol = "%crate_defs", is_definition
  edge ROOT_NODE -> crate_defs

  ;; Edge to crate-level definitions, typically defined in the root `lib.rs`.
  node out_to_crate_defs
  attr (out_to_crate_defs) push_symbol = "%crate_defs"
  edge out_to_crate_defs -> ROOT_NODE

  ;; There is no dual of crate_defs. XXX Why? ???
  ;; There is no dual of out_to_crate_defs. XXX Why? ???

  ;; As we process the path, we're building two graph-paths: out_to_super and
  ;; in_from_root. XXX TODO figure out duals
  ;;
  ;; out_to_super: Graph path that pushes the enclosing module's canonical path and
  ;; then jumps to the root node, for implementing `super` in this module.
  var out_to_super = out_to_crate_defs

  ;; in_from_root: End node of a graph path from ROOT_NODE to the scope node for
  ;; this module, popping names as we go, so that when another file wants to
  ;; resolve `crate::a::b::c::X`, that can resolve to something in the file
  ;; `src/a/b/c.rs`.
  var in_from_root = crate_defs

  ;; To implement `mod child;` so that `child` refers to a module defined in
  ;; another file, we need a gadget to reach the nodes representing this
  ;; module, in all other files. We call this gadget `to_anyfile`. It works by
  ;; pushing the canonical path, then exiting to ROOT_NODE. Other files then
  ;; define paths from ROOT_NODE that pop that exact stack of symbols.
  var to_anyfile = #null

  ;; Doing this properly will involve understanding Cargo package layout in
  ;; detail :-P
  scan FILE_PATH {
    "(main|lib|mod|src/bin/[^/]+)\.rs$" {
      ;; Do not push this filename onto either in_from_root or out_to_super.
      ;; TODO - test if super works in files named mod.rs
      set to_anyfile = out_to_crate_defs
    }

    "([^/]+)\.rs$" {
      ;; Extend `in_from_root` to pop this module name; but don't change `out_to_super`.
      node pop_types
      attr (pop_types) pop_symbol = "%types"
      edge in_from_root -> pop_types
      attr (in_from_root -> pop_types) precedence = 1
      node pop_name
      attr (pop_name) pop_symbol = $1
      edge pop_types -> pop_name
      set in_from_root = pop_name

      ;; To reach this module but in another file, we have to push this
      ;; module's canonical path (in reverse order, as usual), then go to
      ;; ROOT_NODE. We push the canonical path by pushing this module's name
      ;; and `%types`, then pushing the parent module's canonical path in
      ;; reverse order (using `out_to_super`).
      node anyfile1
      attr (anyfile1) push_symbol = $1
      node anyfile2
      attr (anyfile2) push_symbol = "%types"
      edge anyfile1 -> anyfile2
      edge anyfile2 -> out_to_super
      set to_anyfile = anyfile1
    }

    "src/" {
      ;; Reset.
      set out_to_super = out_to_crate_defs
      set to_anyfile = out_to_crate_defs
      set in_from_root = crate_defs
    }

    "([^/]+)/" {
      ;; Extend `in_from_root` to pop this module name.
      node pop_types
      attr (pop_types) pop_symbol = "%types"
      edge in_from_root -> pop_types
      attr (in_from_root -> pop_types) precedence = 1
      node pop_name
      attr (pop_name) pop_symbol = $1
      edge pop_types -> pop_name
      set in_from_root = pop_name

      ;; Extend `out_to_super` to push this module name.
      node push_types
      attr (push_types) push_symbol = "%types"
      edge push_types -> out_to_super
      node push_name
      attr (push_name) push_symbol = $1
      edge push_name -> push_types
      set out_to_super = push_name
    }
  }

  ;; Use in_from_root as the definition node for this source file.
  let @root.def = in_from_root
  edge in_from_root -> @root.type_defs
  edge in_from_root -> @root.value_defs
  edge in_from_root -> @root.def_any

  ;; Bind `self` to a node with the same out-edges as @root.def. (Can't use the
  ;; same node because TSG doesn't really support aliases: only nodes with type
  ;; = "pop_symbol" can be definitions.)
  node self
  attr (self) source_node = @root, pop_symbol = "self", is_definition
  edge @root.type_defs -> self
  edge self -> @root.type_defs
  edge self -> @root.value_defs
  edge self -> @root.def_any

  ;; Bind `super` to the out_to_super path.
  node pop_super
  attr (pop_super) pop_symbol = "super"
  edge @root.type_defs -> pop_super
  edge pop_super -> out_to_super

  ;; Bind `%anyfile` to a graph path that pushes this module's canonical name,
  ;; then goes to the shared ROOT_NODE. See comment on to_anyfile.
  node pop_anyfile
  attr (pop_anyfile) pop_symbol = "%anyfile"
  edge @root.def -> pop_anyfile
  edge self -> pop_anyfile ;; keep self's out-edges the same as the module's out-edges
  edge pop_anyfile -> to_anyfile
}



;; # Qualified access
;;
;; What tree-sitter-rust calls a `scoped_identifier` is what the rest of the
;; Rust world calls a path. Of course "path" is a bit overloaded with
;; stack-graphs.

;; ## Namespaces for qualified access
;;
;; In which we set up paths from definitions to their members, `self`, `super`,
;; and `crate`.
;;
;; In `a::b`, the `a` refers to a type, trait, or module. To resolve `b`, we
;; follow a path that leads first to the definition of `a`, then from there
;; must be able to match `"%types" "b"` or `"%values" "b"`. Note that when `::`
;; is used, there's no inheritance: we want a binding that is a member of `a`
;; in particular and not some enclosing block scope.
;;
;; Therefore, nodes that represent the contents of a type aren't lexical
;; scopes. They have no inheritance edge. But they do have `"%types"` and
;; `"%values"` edges and thus can serve as an AST node's `.scope`.

;; Install a path from a module definition to the types defined inside it.
;; Also hook up `self`, `super`, and `crate` for declared modules.
(mod_item name: (identifier) @name body: (declaration_list) @body) @mod {
  edge @mod.def -> @body.value_defs
  edge @mod.def -> @body.type_defs
  edge @mod.def -> @body.def_any

  ;; Define `self` as a node effectively identical to `@mod.def`. (Can't use
  ;; the same node because TSG doesn't support aliases.)
  node self
  attr (self) source_node = @name, pop_symbol = "self", is_definition
  edge @body.type_defs -> self
  edge self -> @body.value_defs
  edge self -> @body.type_defs
  edge self -> @body.def_any

  ;; Bind `super` in a declared module as an alias for `self` in the enclosing
  ;; module.
  node super
  attr (super) pop_symbol = "super"
  node super_1
  attr (super_1) push_symbol = "self"
  node super_2
  attr (super_2) push_symbol = "%types"
  edge @body.type_defs -> super
  edge super -> super_1
  edge super_1 -> super_2
  edge super_2 -> @mod.scope
}

;; Trait members are not in scope for unqualified access, but they can be
;; accessed by paths via the trait.
(trait_item body: (declaration_list) @decls) @trait {
  edge @trait.def -> @decls.value_defs
  edge @trait.def -> @decls.type_defs
}

;; Install a path from a struct definition to its fields.
;;
;; *   `.fields` - On `(field_declaration_list)` nodes. A node that pops
;;     "%fields" and leads to the field definitions.

(struct_item body: (field_declaration_list) @fields) @struct {
  edge @struct.def -> @fields.fields
}

;; Note this is used by struct-like enum variants too.
(field_declaration_list) @fields {
  node @fields.fields
  attr (@fields.fields) pop_symbol = "%fields"
}

(field_declaration_list (field_declaration name: (_) @field type: (_) @type)) @fields {
  node @field.def
  attr (@field.def) node_definition = @field
  edge @fields.fields -> @field.def

  node t
  attr (t) pop_symbol = "%type"
  edge @field.def -> t
  edge t -> @type.to_def
}

;; Install paths from an enum to its variants.
;;
;; Since the enum can serve as a qualifier in paths, including in imports, it
;; must have edges that pop "%types", "%values", and "%any", leading to the
;; names defined in those namespaces by the enum's variants.
;;
;; *   `.variants_types`, `.variants_values` - On `enum_item`s. The namespaces
;;     in which enum variants are bound.
(enum_item name: (type_identifier) @name ) @enum {
  node @enum.variants_types
  node t
  attr (t) pop_symbol = "%types"
  edge @enum.def -> t
  edge t -> @enum.variants_types

  node @enum.variants_values
  node v
  attr (v) pop_symbol = "%values"
  edge @enum.def -> v
  edge v -> @enum.variants_values

  ;; The `%any` namespace supports looking up the identifier that's the last
  ;; component of a use-declaration that imports from an enum.
  node any
  attr (any) pop_symbol = "%any"
  node to_types
  attr (to_types) push_symbol = "%types"
  node to_values
  attr (to_values) push_symbol = "%values"
  edge @enum.def -> any
  edge any -> to_types
  edge to_types -> t
  edge any -> to_values
  edge to_values -> v
}

(enum_item
  body: (enum_variant_list
    (enum_variant
      name: (identifier) @name
      (field_declaration_list)? @fields
    ) @variant
  )
) @enum {
  node @variant.def
  attr (@variant.def) node_definition = @name
  if some @fields {
    edge @enum.variants_types -> @variant.def
    edge @variant.def -> @fields.fields
  }
  edge @enum.variants_values -> @variant.def
}


;; ## Starting scope for a path

;; Thread the current lexical scope down the left edge of a path AST.
[
  (scoped_identifier path: (_) @child) @parent
  (scoped_type_identifier path: (_) @child) @parent
] {
  let @child.scope = @parent.scope
  let @child.scope_uses = @parent.scope_uses
}

;; ## Qualifiers
;;
;; The `path:` named child of a `(scoped_identifier)`,
;; `(scoped_type_identifier)`, or `(scoped_use_list)` is called the qualifier,
;; and can be one of:
;;
;; -   `(self)`
;; -   `(super)`.
;; -   `(crate)`
;; -   A nested `(scoped_identifier)`.
;; -   An `(identifier)`. I think the grammar treats `Self` as an identifier
;;     and we just resolve it lexically.
;; -   `(bracketed_type)`, as in `<T>::`, `<Vec<T>>::`, or `<T as ToString>::`.
;;     We currently support only the simplest case.
;; -   `(generic_type)`, as in `Vec::<T>::`. We don't support generics at all.
;; -   Nothing, as in `::std`. This isn't supported yet; it means the
;;     extern prelude.
;;
;; Below are the rules implementing each of these cases (the ones we support,
;; anyway) by setting the `.to_def` variable of the qualifier to a node that
;; leads to the appropriate scope. The name to the right of `::` is resolved
;; in that scope.

;; `(self)` and `(super)` are, so far, resolved lexically.
;;
;; Rust probably handles these as special cases, but I think this gives the
;; correct result for all cases Rust allows.
[
  (scoped_identifier path: [(self) (super)] @keyword)
  (scoped_type_identifier path: [(self) (super)] @keyword)
  (scoped_use_list path: [(self) (super)] @keyword)
  (use_as_clause path: [(self) (super)] @keyword)
  (use_list [(self) (super)] @keyword)
  (use_wildcard . [(self) (super)] @keyword)
  (visibility_modifier [(self) (super)] @keyword)
  ;; bogus if it happens, but accepted by the parser:
  (range_pattern [(self) (super)] @keyword)
] {
  node @keyword.to_def
  attr (@keyword.to_def) node_reference = @keyword

  let t = (node)
  attr (t) push_symbol = "%types"
  edge @keyword.to_def -> t
  edge t -> @keyword.scope

  node @keyword.use
  attr (@keyword.use) pop_symbol = (source-text @keyword)

  let u = (node)
  attr (u) push_symbol = "%type_uses"
  edge t -> @keyword.use
  edge @keyword.scope_uses -> t
}

;; `(crate)` resolves to the root.
[
  (scoped_identifier path: (crate) @keyword)
  (scoped_type_identifier path: (crate) @keyword)
  (scoped_use_list path: (crate) @keyword)
  (use_as_clause path: (crate) @keyword)
  (use_list (crate) @keyword)
  (use_wildcard . (crate) @keyword)
  (visibility_modifier (crate) @keyword)
  ;; bogus if it happens, but accepted by the parser:
  (range_pattern (crate) @keyword)
] {
  ;; All uses of `crate` are threaded through the root node,
  ;; so they can cross file boundaries.
  node @keyword.to_def
  attr (@keyword.to_def) type = "push_symbol", symbol = "%crate_defs", is_reference, source_node = @keyword
  edge @keyword.to_def -> ROOT_NODE

  node @keyword.use
  attr (@keyword.use) pop_symbol = "%crate_uses"
  edge ROOT_NODE -> @keyword.use
}

;; An identifier at the start of a path is resolved relative to the `.scope`.
;; This means that in expression or type-expression context, it can resolve to
;; a module, type, or trait in the current lexical scope. (It could refer to a
;; crate in the extern prelude, but we don't support that yet.)
;;
;; (If that whole path is inside the braces of a `(scoped_use_list)`, as for
;; the path `io::Error` in `use std::{io::Error};`, then the curret lexical
;; scope would be the wrong place to start. Therefore the `.scope` must be
;; determined by its qualifier instead, in this case `std::`. This isn't
;; implemented yet.)
[
  (scoped_identifier path: (identifier) @name)
  (scoped_type_identifier path: (identifier) @name)
  (scoped_use_list path: (identifier) @name)
  (visibility_modifier (identifier) @name)
  ;; bogus if it happens, but accepted by the parser:
  (range_pattern (identifier) @name)
] {
  ;; For now, a copy of the code for resolving `(type_identifier)`.
  node @name.to_def
  attr (@name.to_def) node_reference = @name

  let t = (node)
  attr (t) push_symbol = "%types"
  edge @name.to_def -> t
  edge t -> @name.scope

  ;; Dual.
  node @name.use
  attr (@name.use) pop_symbol = (source-text @name)

  let u = (node)
  attr (u) pop_symbol = "%type_uses"
  edge u -> @name.use
  edge @name.scope_uses -> u
}

(bracketed_type (_) @child) @parent {
  let @parent.to_def = @child.to_def
  let @parent.use = @child.use
}

(qualified_type alias: (_) @trait) @parent {
  let @parent.to_def = @trait.to_def
  let @parent.use = @trait.use
}


;; ## Marking the context of expressions
;;
;; *   `.context` - On all expression, type expression, and pattern nodes. This
;;     is for scoped identifiers and fields/methods. The context of a path
;;     determines which namespace to search.
;;
;; *   `.fcontext` - On all expression nodes, but only used on
;;     `(field_expression)` nodes.  Is either "%fields" or "%methods"
;;     depending on whether this expression appears in a context where it
;;     is immediately called, like the `obj.method` in `obj.method();` as
;;     opposed to the `s.field` in `let v = s.field;`. Necessary because
;;     fields and methods live in two different namespaces.

;; Note: This is a complete copy of the huge list under "Marking unqualified
;; references". Obviously the duplication is very bad. I don't know how else to
;; get this effect.
[
  ;; ### Expressions
  (arguments (_) @here)
  (array_expression (_) @here)
  (assignment_expression left: (_) @here)
  (assignment_expression right: (_) @here)
  (await_expression (_) @here)
  (base_field_initializer (_) @here)
  (binary_expression left: (_) @here)
  (binary_expression right: (_) @here)
  (break_expression (_) @here)
  (call_expression function: (_) @here) @call
  (compound_assignment_expr left: (_) @here)
  (compound_assignment_expr right: (_) @here)
  (field_expression value: (_) @here)
  (field_initializer value: (_) @here)
  (for_expression value: (_) @here)
  (generic_function function: (_) @here)
  (if_expression condition: (_) @here)
  (if_let_expression value: (_) @here)
  (index_expression (_) @here)
  (match_expression value: (_) @here)
  (match_pattern condition: (_) @here)
  (parenthesized_expression (_) @here)
  (range_expression (_) @here)
  (reference_expression value: (_) @here)
  (return_expression (_) @here)
  (shorthand_field_initializer (_) @here)
  (try_expression (_) @here)
  (tuple_expression (_) @here)
  (type_cast_expression value: (_) @here)
  (unary_expression (_) @here)
  (while_expression condition: (_) @here)
  (while_let_expression value: (_) @here)
  (yield_expression (_) @here)

  ;; ### Types
  (array_type length: (_) @here)

  ;; ### Statements
  (block (_)* (_) @here)
  (expression_statement (_) @here)
  (let_declaration value: (_) @here)

  ;; ### Items
  (const_item value: (_) @here)
  (static_item value: (_) @here)
] {
  let @here.context = "%values"

  if some @call {
    let @here.fcontext = "%methods"
  } else {
    let @here.fcontext = "%fields"
  }
}

;; Note: This is a complete copy of the second huge list under "Marking
;; unqualified references".
[
  ;; ### Types
  (abstract_type trait: (_) @here)
  (array_type element: (_) @here)
  (bounded_type (_) @here)
  (dynamic_type trait: (_) @here)
  (function_type trait: (_) @here)  ;; only for Fn, FnMut, FnOnce
  (function_type return_type: (_) @here)
  (generic_type type: (_) @here)
  (generic_type_with_turbofish type: (_) @here)
  (pointer_type type: (_) @here)
  (qualified_type type: (_) @here)
  (qualified_type alias: (_) @here)
  (reference_type type: (_) @here)
  (scoped_type_identifier path: (_) @here)
  (tuple_type (_) @here)
  (type_binding type: (_) @here)

  ;; ### Expressions
  (type_cast_expression type: (_) @here)
  (bracketed_type (_) @here)
  (struct_expression name: (_) @here)
  (scoped_identifier path: (_) @here)

  ;; ### Patterns
  (struct_pattern type: (_) @here)

  ;; ### Items
  (const_item type: (_) @here)
  (field_declaration type: (_) @here)
  (function_item return_type: (_) @here)
  (impl_item trait: (_) @here)
  (impl_item type: (_) @here)
  (ordered_field_declaration_list type: (_) @here)
  (parameter type: (_) @here)
  (static_item type: (_) @here)
  (trait_bounds (_) @here)
  (type_item type: (_) @here)
  (where_predicate left: (_) @here)

  ;; ### Statements
  (let_declaration type: (_) @here)
] {
  let @here.context = "%types"
}

;; Ambiguous contexts
(type_arguments (_) @here) {
  ;; type or value depending on the generic, I think
  let @here.context = "%types" ;; bug
}

(tuple_struct_pattern type: (_) @here) {
  ;; type or value, whichever comes first
  let @here.context = "%values" ;; BUG - try "%any"
}

;; Pattern context
[
  (for_expression pattern: (_) @here)
  (if_let_expression pattern: (_) @here)
  (while_let_expression pattern: (_) @here)
  (let_declaration pattern: (_) @here)
  (parameter pattern: (_) @here)
  (closure_parameters (_) @here)
  (match_pattern . (_) @here)
  (tuple_pattern (_) @here)
  (tuple_struct_pattern type: (_) (_) @here)
  (slice_pattern (_) @here)
  (field_pattern name: (shorthand_field_identifier) @here)
  (field_pattern pattern: (_) @here)
  (mut_pattern (mutable_specifier) (_) @here)
  (ref_pattern (_) @here)
  (captured_pattern (identifier) @here "@" (_))
  (captured_pattern (identifier) "@" (_) @here)
  (reference_pattern "&" (mutable_specifier)? (_) @here)
  (or_pattern (_) @here)
] {
  let @here.context = "%pattern"
}

;; Macro context
(macro_invocation macro: (_) @here) {
  let @here.context = "%macro"
}

;; Use-path context
[
  (scoped_use_list path: (_) @here)
  (use_as_clause path: (_) @here)
  (use_declaration argument: (_) @here)
  (use_list (_) @here)
  (use_wildcard (_) @here "::" "*")
] {
  ;; Here we may be importing either a type or a value, or both. We can't
  ;; locally tell which, so importable scopes must provide that `%any` reaches
  ;; both the `%values` namespace and the `%types` namespace.
  let @here.context = "%any"
}


;; ## Resolving qualified identifiers in paths
;;
;; In a path like `a::b::c::d`, each segment except the initial `a` is qualified.
;; For the initial segment, see the section on "Qualifiers".
;;
;; (scoped_identifier) appears in some very different contexts,
;; including (use_list), as in `use some_crate::{self, std::io};` where
;; `std::io` ends up having an unusual meaning.

[
  (scoped_identifier path: (_)? @parent name: (identifier) @name) @path
  (scoped_type_identifier path: (_)? @parent name: (type_identifier) @name) @path
] {
  node @name.to_def
  attr (@name.to_def) node_reference = @name
  let @path.to_def = @name.to_def

  node s
  attr (s) push_symbol = (replace @path.context "%pattern" "%values")
  edge @name.to_def -> s

  node @name.use
  attr (@name.use) pop_symbol = (source-text @name)
  let @path.use = @name.use

  node u
  attr (u) pop_symbol = (replace (replace @path.context "%pattern" "%values") "^%types$" "%type_uses")
  edge u -> @name.use

  if some @parent {
    let @name.scope = @parent.to_def
    let @name.scope_uses = @parent.use ;; XXX not sure about this one ???
  } else {
    ;; `::foo` syntax. This is a crate name. TODO - connect s to the extern
    ;; crates. For now, we bogusly treat this like unqualified `foo` rather
    ;; than leave @name.scope unset and fail the whole file.
    let @name.scope = @path.scope
    let @name.scope_uses = @path.scope_uses
  }
  edge s -> @name.scope
  edge @name.scope_uses -> u
}

;; Set the scope of the `list:` child of a `(scoped_use_list)`.
(scoped_use_list path: (_)? @parent list: (use_list) @child) @context {
  if some @parent {
    let @child.scope = @parent.to_def
    let @child.scope_uses = @parent.use ;; XXX not sure about this one ???
  } else {
    ;; `use ::{foo};` syntax. TODO - connect this scope to the extern crates.
    ;; For now, we bogusly treat this like unqualified `foo` rather than leave
    ;; @child.scope unset and fail the whole file.
    let @child.scope = @context.scope
    let @child.scope_uses = @context.scope_uses
  }
}



;; # Fields

;; Link identifiers after `.` to the corresponding field or method definition.
;;
;; Note: Method calls parse as (call_expression function: (field_expression)),
;; so this rule covers uses of both fields and methods.
(field_expression value: (_) @value field: (_) @field) @expr {
  node @field.to_def
  attr (@field.to_def) node_reference = @field
  node f1
  attr (f1) push_symbol = @expr.fcontext ;; either "%fields" or "%method"
  edge @field.to_def -> f1
  edge f1 -> @value.type

  node @expr.type
  attr (@expr.type) push_symbol = "%type"
  edge @expr.type -> @field.to_def
}

;; Link fields in struct expressions and patterns to their definitions.
[
  (struct_expression
    body: (field_initializer_list
      (field_initializer name: (field_identifier) @field_name)
    )
  )
  (struct_pattern (field_pattern name: (_) @field_name))
] {
  node @field_name.to_def
  attr (@field_name.to_def) node_reference = @field_name
}

(struct_expression
  name: [(type_identifier) (scoped_type_identifier)] @ty
  body: (field_initializer_list [
    (field_initializer name: (field_identifier) @field_name)
    (shorthand_field_initializer (identifier) @field_name)
  ])
) {
  node push_fields
  attr (push_fields) push_symbol = "%fields"
  edge @field_name.to_def -> push_fields
  edge push_fields -> @ty.to_def
}

(struct_pattern
  type: [(type_identifier) (scoped_type_identifier)] @ty
  [
    (field_pattern name: (_) @field_name)
    (shorthand_field_identifier) @field_name
  ]
) {
  node push_fields
  attr (push_fields) push_symbol = "%fields"
  edge @field_name.to_def -> push_fields
  edge push_fields -> @ty.to_def
}



;; # Lifetimes
;; See also `(type_parameters (lifetime) @lifetime) @params` above.

;; Uses of lifetimes.
[
  (where_predicate left: (lifetime) @lifetime)
  (trait_bounds (lifetime) @lifetime)
  (self_parameter (lifetime) @lifetime)
  (bounded_type (lifetime) @lifetime)
  (type_arguments (lifetime) @lifetime)
  (reference_type (lifetime) @lifetime)
] {
  node @lifetime.to_def
  attr (@lifetime.to_def) node_reference = @lifetime
  node t
  attr (t) push_symbol = "%types"
  edge @lifetime.to_def -> t
  edge t -> @lifetime.scope
}



;; # Loop labels
;; These look like lifetimes but inhabit a separate namespace.

;; Uses of loop labels.
[
  (break_expression (loop_label) @label)
  (continue_expression (loop_label) @label)
] @expr {
  node @label.to_def
  attr (@label.to_def) node_reference = @label
  node t
  attr (t) push_symbol = "%loop"
  edge @label.to_def -> t
  edge t -> @expr.scope
}



;; # Imports
;;
;; The code in this section has two goals:
;;
;; -   Support references that appear within `use` declarations, like the
;;     `Error` in `use anyhow::Error;`
;;
;; -   Add `use`-bindings to the lexical scope, so that throughout your code, the
;;     way we handle identifiers is import-aware. If on line 1234 of a file you
;;     have `let map = HashMap::new();`, we want `HashMap` to be linked to the
;;     right definition via the `use hashbrown::HashMap;` on line 12.
;;
;; The bit of syntax between `use` and `;` is called a *UseTree*. It can have
;; several forms:
;;
;;     use w::x::y::z;
;;     use x::memory_management as mm;
;;     use { std::io, tokio::runtime::Runtime };
;;     use std::io::{self, Read};
;;     use std::{io, thread::{self, spawn}};
;;     use hms_pinafore::prelude::*;
;;     use crate as my_root;
;;
;; At the beginning of a UseTree, `self::`, `super::`, `crate::`, and bare `::`
;; can be used to specify where to start the search for items to import.
;;
;; So the full grammar is like this:
;;
;;     UseTree :
;;         UseTreePrefix? UseTreeTail
;;
;;     UseTreePrefix :
;;         `self` `::`
;;         (`super` `::`)+
;;         `crate` `::`
;;         `::`
;;
;;     UseTreeTail :
;;         UseTreeLeaf Alias?
;;         Identifier `::` UseTreeTail
;;         `{` (UseTreeTail (`,` UseTreeTail)* `,`?)? `}`
;;         `*`
;;
;;     UseTreeLeaf :
;;         Identifier
;;         `self`  // only within a {} list with non-empty prefix
;;         `crate`  // only without any prefix and with alias
;;
;;     Alias :
;;         `as` Identifier
;;         `as` `_`
;;
;; Unfortunately the way grammar.js renders these is backwards for processing
;; them. Ideally we'd treat `::` as right-associative here, so that `x::y::z`
;; is rendered as `(:: x (:: y (identifier z)))`. This is the opposite of how
;; the syntax tree is constructed for everything else in the language, though.
;; So what we actually get is `(:: (:: (identifier x) y) z)`.
;;
;;    use_clause:
;;        (self)  // we accept it but this isn't actually legal Rust syntax
;;        (super) // same
;;        (crate) // same
;;        (identifier)
;;        (scoped_identifier)
;;        (use_as_clause)
;;        (use_list)
;;        (scoped_use_list)
;;        (use_wildcard)
;;
;; Also unfortunately, the same node type `(scoped_identifier)` is used in
;; imports as in expressions, despite the meaning being quite different,
;; especially in the case of the `bar::baz` in `use foo::{bar::baz};`.
;;
;; We assume that the identifier at the beginning of a path in expression
;; context searches exactly the same places as an identifier at the beginning
;; of a path in `use_clause` context.

;; Add `use-bindings` to the lexical scope.
[
  (use_declaration [
    (identifier) @name
    (scoped_identifier name: (identifier) @name)
  ])
  (use_list [
    (identifier) @name
    (scoped_identifier name: (identifier) @name)
  ])
  (use_as_clause
    path: [
      (identifier) @name
      (scoped_identifier name: (identifier) @name)
      (crate) @crate_root
    ]
    alias: (_) @alias
  )
  ;; In `use a::b::{self, ...}`, bind `b`.
  (scoped_use_list
    path: [
      (identifier) @name
      (scoped_identifier name: (identifier) @name)
      (crate) @crate_root
    ]
    (use_list [
      (self)
      (use_as_clause path: (self) alias: (_) @alias)
    ])
  )
] @import {
  ;; Make a binding for @name in the type namespace. This gadget pops `"type"
  ;; @name` (or @alias instead, if present), then forwards to the imported item
  ;; by re-pushing `"%types" @name` and exiting to @name.scope, which is
  ;; selected by other rules.
  node type_relay
  node type_use_relay
  if some @alias {
    attr (type_relay) type = "pop_symbol", node_symbol = @alias
    attr (type_use_relay) type = "push_symbol", node_symbol = @alias
  } else {
    attr (type_relay) type = "pop_symbol", node_symbol = @name
    attr (type_use_relay) type = "push_symbol", node_symbol = @name
  }
  edge @import.item_type_defs -> type_relay
  edge type_use_relay -> @import.item_type_uses
  if some @crate_root {
    edge type_relay -> @crate_root.to_def
    edge @crate_root.use -> type_use_relay
  } else {
    node t1
    attr (t1) type = "push_symbol", node_symbol = @name
    node t2
    attr (t2) push_symbol = "%types"
    edge type_relay -> t1
    edge t1 -> t2
    edge t2 -> @name.scope

    node u1
    attr (u1) type = "pop_symbol", node_symbol = @name
    node u2
    attr (u2) pop_symbol = "%type_uses"
    edge u1 -> type_use_relay
    edge u2 -> u1
    edge @name.scope_uses -> u2
  }

  ;; Same deal for the value namespace.
  if none @crate_root {
    node value_relay
    if some @alias {
      attr (value_relay) type = "pop_symbol", node_symbol = @alias
    } else {
      attr (value_relay) type = "pop_symbol", node_symbol = @name
    }
    node value_relay1
    attr (value_relay1) type = "push_symbol", node_symbol = @name
    node value_relay2
    attr (value_relay2) push_symbol = "%values"
    edge @import.item_value_defs -> value_relay
    edge value_relay -> value_relay1
    edge value_relay1 -> value_relay2
    edge value_relay2 -> @name.scope
  }

  ;; TODO - need %any propagation here as well? test case would be import of an
  ;; import
}

;; Identifiers in import context, qualified by a scoped_use_list.
;;
;; There is different code for the identifier at the start of a path.
;;
;; Bug: With use-lists it is possible for the same identifier to be both the
;; start and the end of a path, and it's hard to tell when that's happening
;; using only tree-sitter queries. We only implement a single level of
;; use-list; `use {{foo}};` does not work.
[
  (scoped_use_list (use_list (identifier) @ident))
  (scoped_use_list (use_list (use_as_clause path: (identifier) @ident)))
] {
  ;; Implementation note: Compare with the code in sections "Identifiers in
  ;; expression context" and "Identifiers in type context".
  node @ident.to_def
  attr (@ident.to_def) node_reference = @ident

  ;; XXX why does this only do %any and not %types or %values??
  node a
  attr (a) push_symbol = "%any"
  edge @ident.to_def -> a
  edge a -> @ident.scope

  ;; Duals.
  node @ident.use
  attr (@ident.use) pop_symbol = (source-text @ident)

  node u
  attr (u) pop_symbol = "%type_uses"  ;; %type_uses as dual of %any ???
  edge u -> @ident.use
  edge @ident.scope_uses -> u
}

;; Scope inheritance in `use` syntax.
[
  (scoped_use_list path: (_) @child)
  (use_as_clause path: (_) @child)
  (use_declaration argument: (_) @child)
  (use_list (_) @child)
  (use_wildcard (_) @child "::" "*")
] @parent {
  let @child.scope = @parent.scope
  let @child.scope_uses = @parent.scope_uses
}

;; Propagate the binding scopes to the leaves of imports.
[
  (_ (use_list) @child)
  (_ (scoped_use_list) @child)
  (_ (use_as_clause) @child)
] @parent {
  let @child.item_type_defs = @parent.item_type_defs
  let @child.item_value_defs = @parent.item_value_defs
  let @child.item_type_uses = @parent.item_type_uses
}



;; # Types
;;
;; Some nodes in the output graph represent types. Definitions of structs,
;; enums, and unions are an example. Function types are also represented as
;; stack-graph nodes with a special `"%rtype"` edge. The purpose of these nodes
;; is to provide access to the type's fields and methods, since we need to
;; resolve those too, not just item names and variables.
;;
;; To find the method `moo` in `cow.moo()`, push `"moo" "%methods" "%type"
;; "cow" "%values"` (with `"%values"` on top) and exit to the lexical scope.
;; The meaning of this sequence is:
;;
;; -   `"%values"` - look in the values namespace
;; -   `"cow"` - find the definition of `cow`
;; -   `"%type"` - get the type of `cow`
;; -   `"%methods"` - look in that type's methods
;; -   `"moo"` - find the definition of the `moo` method
;;
;; The type inference scheme has four parts:
;;
;; 1.  Linking type-expressions in the syntax tree to types in the scope graph.
;;     Each syntax-node that's a Rust type a `.to_def` scoped variable, a
;;     scope-node that leads to the type definition.
;;
;; 2.  Linking patterns to expected types. Each syntax-node that's a pattern
;;     has a `.expected_type` scoped variable that leads to a type definition,
;;     based on the pattern's context (Rust code outside of the pattern
;;     itself).
;;
;; 3.  Linking value bindings to their types. Each scope-node that
;;     is a definition of a value has a `"%type"` edge that leads to
;;     its type. This is done elsewhere, not in this section; search for
;;     `pop_symbol = "%type"`.
;;
;; 4.  Linking expressions in the syntax tree to types. If we can figure
;;     out the type of an expression, it has a `.type` scoped variable that
;;     leads to its type.


;; ## Type-expressions
;;
;; Part 1 of the type inference scheme.
;;
;; Every type-expression should have a `.to_def` that leads to the type
;; definition. For user-defined types, this works because (type_identifier) and
;; (scoped_type_identifier) nodes all have a `.to_def` that crawls the scopes and
;; finds the corresponding definition.
;;
;; Other types are handled here case by case.

;; Function pointer types. Functions have no fields or methods, but they have
;; an `"%rtype"` edge that is used to infer the type of a (call_expression).
(function_type return_type: (_)? @rtype) @ty {
  node @ty.to_def
  if some @rtype {
    node rtype
    attr (rtype) pop_symbol = "%rtype"
    edge @ty.to_def -> rtype
    edge rtype -> @rtype.to_def
  }
}

;; Treat reference types (`&T` and `&mut T`) as identical to the referred-to
;; type (`T`), for now. This is fine only because we don't do anything much
;; with types yet, except look up fields and methods in `expr.foo` syntax. For
;; that specific purpose, references are quite transparent.
(reference_type type: (_) @inner) @ty {
  let @ty.to_def = @inner.to_def
}

;; Types we don't support yet get a dummy node for `.to_def`, to avoid "undefined
;; scoped variable". It's not hooked up to anything, so any attempt to use it
;; will silently fail to find a path through the graph.
[
  (abstract_type)
  (metavariable)
  (pointer_type)
  (generic_type)
  (tuple_type)
  (unit_type)
  (array_type)
  (macro_invocation)
  (empty_type)
  (dynamic_type)
  (bounded_type)
  (primitive_type)
] @ty {
  node @ty.to_def
  node @ty.use
}


;; ## Expected types for patterns
;;
;; Part 2 of the type inference scheme.
;;
;; *   `.expected_type` - On pattern nodes. Leads to a type definition, the
;;     expected type of the pattern, inferred from the context.

(let_declaration
  pattern: (_) @pattern
  type: (_)? @type
  value: (_)? @expr
) {
  if some @type {
    let @pattern.expected_type = @type.to_def
  } else {
    if some @expr {
      let @pattern.expected_type = @expr.type
    } else {
      node @pattern.expected_type
    }
  }
}

(parameter pattern: (_) @pattern type: (_) @type) {
  let @pattern.expected_type = @type.to_def
}

[
  (if_let_expression pattern: (_) @pattern value: (_) @expr)
  (while_let_expression pattern: (_) @pattern value: (_) @expr)
] {
  let @pattern.expected_type = @expr.type
}

(match_expression
  value: (_) @expr
  body: (match_block (match_arm pattern: (match_pattern . (_) @pattern)))
) {
  let @pattern.expected_type = @expr.type
}

;; Patterns that don't affect the types of subpatterns
[
  (captured_pattern (identifier) @pattern "@" (_))
  (captured_pattern (identifier) "@" (_) @pattern)
  (mut_pattern (mutable_specifier) (_) @pattern)
  (or_pattern (_) @pattern)
] @outer_pattern {
  let @pattern.expected_type = @outer_pattern.expected_type
}

;; Pattern contexts in which we don't support type inference
[
  (for_expression pattern: (_) @pattern)
  (closure_parameters (_) @pattern)
  (tuple_pattern (_) @pattern)
  (tuple_struct_pattern type: (_) (_) @pattern)
  (slice_pattern (_) @pattern)
  (field_pattern name: (shorthand_field_identifier) @pattern)
  (field_pattern pattern: (_) @pattern)
  (ref_pattern (_) @pattern)
  (reference_pattern "&" (mutable_specifier)? (_) @pattern)
] {
  ;; Dummy node, to avoid "undefined scoped variable".
  node @pattern.expected_type
}



;; ## Expression types
;;
;; Part 4 of the type inference scheme.
;;
;; *   `.type` - On all expression nodes. Leads to the definition node of the
;;     expression's type, if we can infer it. Otherwise this can be an empty
;;     node.
;;
;; The `.type` of `(identifier)` and `(self)` nodes, when used as expressions, is
;; set in section "Identifiers in expression context".
;;
;; The `.type` of (field_expression) nodes is set in the "Fields" section.
;;
;; All other expressions must also have a `.type`, set here. We only infer the
;; types of a subset of expressions; the catchall rule at the end gives other
;; expressions an empty node as their `.type`.

(type_cast_expression type: (_) @type) @expr {
  let @expr.type = @type.to_def
}

(call_expression function: (_) @function) @expr {
  node @expr.type
  attr (@expr.type) push_symbol = "%rtype"
  edge @expr.type -> @function.type
}

(parenthesized_expression (_) @inner) @expr {
  let @expr.type = @inner.type
}

(struct_expression name: (_) @type) @expr {
  let @expr.type = @type.to_def
}

;; Bogus: set the type of `&x` to the type of `x`.
;; See the comment at `(reference_type type: (_) @inner)`.
(reference_expression value: (_) @value) @expr {
  let @expr.type = @value.type
}

(block [
  ;; List of all expression node types that don't end in blocks.
  ;; We omit node types for which we don't yet infer types.
  (type_cast_expression) @last_expr
  (call_expression) @last_expr
  (parenthesized_expression) @last_expr
  (struct_expression) @last_expr
  (reference_expression) @last_expr
  ;; When our tree-sitter grammar parses blocks where the final expression is a
  ;; block or ends with a block, it parses this as an expression-statement. I'm
  ;; pretty sure that is wrong. But not certain, because Rust's rules about
  ;; semicolons and blocks are a mess.
  ;;(expression_statement (block) @last_expr .)
  ;;(expression_statement (unsafe_block) @last_expr .)
  (_)
] .) @expr {
  if some @last_expr {
    let @expr.type = @last_expr.type
  } else {
    node @expr.type
  }
}

(block (_)* @stuff) @expr {
  if (is-empty @stuff) {
    node @expr.type
  }
}

(unsafe_block (block) @block) @expr {
  let @expr.type = @block.type
}

[
  (if_expression consequence: (_) @then alternative: (else_clause "else" (_) @else)?)
  (if_let_expression consequence: (_) @then alternative: (else_clause "else" (_) @else)?)
] @expr {
  if some @else {
    node @expr.type
    edge @expr.type -> @then.type
    edge @expr.type -> @else.type
  } else {
    ;; The type is `()`.
    node @expr.type
  }
}

;; Expressions for which we don't yet infer types.
[
  (unary_expression)
  (try_expression)
  (binary_expression)
  (assignment_expression)
  (compound_assignment_expr)
  (return_expression)
  (yield_expression)
  (string_literal)
  (raw_string_literal)
  (char_literal)
  (boolean_literal)
  (integer_literal)
  (float_literal)
  (scoped_identifier)
  (generic_function)
  (await_expression)
  (array_expression)
  (tuple_expression)
  (macro_invocation)
  (unit_expression)
  (break_expression)
  (continue_expression)
  (index_expression)
  (metavariable)
  (closure_expression)
  (async_block)
  (match_expression)
  (while_expression)
  (while_let_expression)
  (loop_expression)
  (for_expression)
  (const_block)
  (range_expression)
] @expr {
  node @expr.type
}
